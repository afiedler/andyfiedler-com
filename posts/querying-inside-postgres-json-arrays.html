<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description" content="Andy Fiedler&#x27;s Personal Site"/><title>Querying Inside Postgres JSON Arrays</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/588d179d14f543de1f7e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/588d179d14f543de1f7e.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-8495f486508069a84016.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.b528922461d10cbe9bfe.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-2f6c726a4c5d3dfd1e8f.js" as="script"/><link rel="preload" href="/_next/static/chunks/0a3463f7b698f32fd7af40216f1292ceb318b3f7.39ce756e4870b72d4174.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-29dccdc32ec4574aab67.js" as="script"/></head><body><div id="__next"><div id="main"><div class="max-w-screen-md mx-auto px-4"><div class="flex items-center justify-between py-6 lg:py-10"><a href="/" class="flex items-center"><p class="font-body font-bold text-2xl text-primary dark:text-white">Andy Fiedler</p></a><div class="flex items-center lg:hidden"><svg width="24" height="15" xmlns="http://www.w3.org/2000/svg" class="fill-current text-primary dark:text-white"><g fill-rule="evenodd"><rect width="24" height="3" rx="1.5"></rect><rect x="8" y="6" width="16" height="3" rx="1.5"></rect><rect x="4" y="12" width="20" height="3" rx="1.5"></rect></g></svg></div><div class="hidden lg:block"><ul class="flex items-center"><li class="mr-6 relative group mb-1"><div class="absolute left-0 bottom-0 w-full transition-all h-0 group-hover:h-2 group-hover:bg-yellow opacity-75 z-20"></div><a href="/posts" class="font-body font-medium text-lg text-primary dark:text-white group-hover:text-green dark:group-hover:text-secondary px-2 z-30 block relative transition-colors">Posts</a></li><li><i class="bx text-3xl text-primary dark:text-white cursor-pointer"></i></li></ul></div><div class="bg-black bg-opacity-80 fixed inset-0 z-20 flex opacity-0 pointer-events-none transition-opacity lg:hidden "><div class="ml-auto bg-blue-600 w-2/3 md:w-1/3 p-4"><svg viewBox="0 0 20 20" width="24" height="24" xmlns="http://www.w3.org/2000/svg" class="fill-current text-white absolute top-0 right-0 mt-4 mr-4"><path d="M15.898,4.045c-0.271-0.272-0.713-0.272-0.986,0l-4.71,4.711L5.493,4.045c-0.272-0.272-0.714-0.272-0.986,0s-0.272,0.714,0,0.986l4.709,4.711l-4.71,4.711c-0.272,0.271-0.272,0.713,0,0.986c0.136,0.136,0.314,0.203,0.492,0.203c0.179,0,0.357-0.067,0.493-0.203l4.711-4.711l4.71,4.711c0.137,0.136,0.314,0.203,0.494,0.203c0.178,0,0.355-0.067,0.492-0.203c0.273-0.273,0.273-0.715,0-0.986l-4.711-4.711l4.711-4.711C16.172,4.759,16.172,4.317,15.898,4.045z"></path></svg><i class="absolute top-0 right-0 mt-4 mr-4"></i><ul class="flex flex-col mt-8"><li class=""><a href="/posts" class="font-body font-medium text-lg text-white px-2 block mb-3">Posts</a></li></ul></div></div></div></div><div class="max-w-screen-md mx-auto px-4"><div class="pt-16 lg:pt-20"><div class="border-b border-grey-lighter pb-8 sm:pb-12"><h2 class="font-body font-semibold text-primary dark:text-white text-3xl sm:text-4xl md:text-5xl block leading-tight">Querying Inside Postgres JSON Arrays</h2><div class="flex items-center pt-5 sm:pt-8"><p class="font-body font-light text-primary dark:text-white pr-2">2014-03-14 12:17:58 -0400</p></div></div><article class="border-b border-grey-lighter py-8 sm:py-12 prose prose dark:prose-dark max-w-none"><p>Postgres JSON support is pretty amazing. I've been using it extensively for storing semi-structured data for a project and it has been great for that use case. In Postgres 9.3, the maintainers added the ability to perform some simple queries on JSON structures and a few functions to convert from JSON to Postgres arrays and result sets.</p>
<p>One feature that I couldn't figure out how to implement using the built-in Postgres functions was the ability to query within a JSON array. This is fairly critical for lots of the reporting queries that I've been building over the part few days. Suppose you have some JSON like this, stored in two rows in a table called "orders", in the column "json_field":</p>
<div class="remark-highlight"><pre class="language-js"><code class="language-js"><span class="token comment">// Row 1, "json_field" column -----</span>
<span class="token punctuation">{</span>
   <span class="token string">"products"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"Fish Tank"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"Bird Feeder"</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

<span class="token comment">// Row 2, "json_field" column -----</span>
<span class="token punctuation">{</span>
   <span class="token string">"products"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
      <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"Bird Feeder"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token operator">:</span> <span class="token string">"Cat Pole"</span> <span class="token punctuation">}</span>
   <span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div>
<p>If you want to run a query like "find all distinct IDs in the json_field's products array", you can't do that with the built in JSON functions that Postgres currently supplies (as far as I'm aware!). This is a fairly common use case, especially for reporting.</p>
<p>To get this work, I wrote this simple PgPL/SQL function to map a JSON array.</p>
<div class="remark-highlight"><pre class="language-pgpsql"><code class="language-pgpsql">CREATE OR REPLACE FUNCTION json_array_map(json_arr json, path TEXT[]) RETURNS json[]
LANGUAGE plpgsql IMMUTABLE AS $$
DECLARE
	rec json;
	len int;
	ret json[];
BEGIN
	-- If json_arr is not an array, return an empty array as the result
	BEGIN
		len := json_array_length(json_arr);
	EXCEPTION
		WHEN OTHERS THEN
			RETURN ret;
	END;

	-- Apply mapping in a loop
	FOR rec IN SELECT json_array_elements#&#x26;gt;path FROM json_array_elements(json_arr)
	LOOP
		ret := array_append(ret,rec);
	END LOOP;
	RETURN ret;
END $$;</code></pre></div>
<p>What this function does is given a JSON array as "json_arr" and a JSON path as "path", it will loop through all elements of the JSON array, locate the element at the path, and store it in a Postgres native array of JSON elements. You can then use other Postgres array functions to aggregate it.</p>
<p>For the query above where we want to find distinct product IDs in the orders table, we could write something like this:</p>
<div class="remark-highlight"><pre class="language-pgpsql"><code class="language-pgpsql">SELECT DISTINCT unnest(json_array_map(orders.json_field#&#x26;gt;&#x26;#39;{products}&#x26;#39;, &#x26;#39;{id}&#x26;#39;::text[]))::text AS &#x26;quot;id&#x26;quot; FROM orders;</code></pre></div>
<p>That would give you the result:</p>
<h2><pre> id</h2>
<p> 2
3
1</pre>
Pretty cool!</p>
</article></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"querying-inside-postgres-json-arrays","contentHtml":"\u003cp\u003ePostgres JSON support is pretty amazing. I've been using it extensively for storing semi-structured data for a project and it has been great for that use case. In Postgres 9.3, the maintainers added the ability to perform some simple queries on JSON structures and a few functions to convert from JSON to Postgres arrays and result sets.\u003c/p\u003e\n\u003cp\u003eOne feature that I couldn't figure out how to implement using the built-in Postgres functions was the ability to query within a JSON array. This is fairly critical for lots of the reporting queries that I've been building over the part few days. Suppose you have some JSON like this, stored in two rows in a table called \"orders\", in the column \"json_field\":\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-js\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"token comment\"\u003e// Row 1, \"json_field\" column -----\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n   \u003cspan class=\"token string\"\u003e\"products\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"id\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e1\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"name\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"Fish Tank\"\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"id\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"name\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"Bird Feeder\"\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n   \u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\n\u003cspan class=\"token comment\"\u003e// Row 2, \"json_field\" column -----\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e\n   \u003cspan class=\"token string\"\u003e\"products\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e[\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"id\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e2\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"name\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"Bird Feeder\"\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e\n      \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"id\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token number\"\u003e3\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"name\"\u003c/span\u003e\u003cspan class=\"token operator\"\u003e:\u003c/span\u003e \u003cspan class=\"token string\"\u003e\"Cat Pole\"\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n   \u003cspan class=\"token punctuation\"\u003e]\u003c/span\u003e\n\u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIf you want to run a query like \"find all distinct IDs in the json_field's products array\", you can't do that with the built in JSON functions that Postgres currently supplies (as far as I'm aware!). This is a fairly common use case, especially for reporting.\u003c/p\u003e\n\u003cp\u003eTo get this work, I wrote this simple PgPL/SQL function to map a JSON array.\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-pgpsql\"\u003e\u003ccode class=\"language-pgpsql\"\u003eCREATE OR REPLACE FUNCTION json_array_map(json_arr json, path TEXT[]) RETURNS json[]\nLANGUAGE plpgsql IMMUTABLE AS $$\nDECLARE\n\trec json;\n\tlen int;\n\tret json[];\nBEGIN\n\t-- If json_arr is not an array, return an empty array as the result\n\tBEGIN\n\t\tlen := json_array_length(json_arr);\n\tEXCEPTION\n\t\tWHEN OTHERS THEN\n\t\t\tRETURN ret;\n\tEND;\n\n\t-- Apply mapping in a loop\n\tFOR rec IN SELECT json_array_elements#\u0026#x26;gt;path FROM json_array_elements(json_arr)\n\tLOOP\n\t\tret := array_append(ret,rec);\n\tEND LOOP;\n\tRETURN ret;\nEND $$;\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWhat this function does is given a JSON array as \"json_arr\" and a JSON path as \"path\", it will loop through all elements of the JSON array, locate the element at the path, and store it in a Postgres native array of JSON elements. You can then use other Postgres array functions to aggregate it.\u003c/p\u003e\n\u003cp\u003eFor the query above where we want to find distinct product IDs in the orders table, we could write something like this:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-pgpsql\"\u003e\u003ccode class=\"language-pgpsql\"\u003eSELECT DISTINCT unnest(json_array_map(orders.json_field#\u0026#x26;gt;\u0026#x26;#39;{products}\u0026#x26;#39;, \u0026#x26;#39;{id}\u0026#x26;#39;::text[]))::text AS \u0026#x26;quot;id\u0026#x26;quot; FROM orders;\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThat would give you the result:\u003c/p\u003e\n\u003ch2\u003e\u003cpre\u003e id\u003c/h2\u003e\n\u003cp\u003e 2\n3\n1\u003c/pre\u003e\nPretty cool!\u003c/p\u003e\n","layout":"post","status":"publish","published":true,"title":"Querying Inside Postgres JSON Arrays","author":{"display_name":"afiedler","login":"afiedler","email":"andy@andyfiedler.com","url":""},"author_login":"afiedler","author_email":"andy@andyfiedler.com","wordpress_id":260,"wordpress_url":"http://andyfiedler.com/?p=260","date":"2014-03-14 12:17:58 -0400","date_gmt":"2014-03-14 16:17:58 -0400","categories":["Tech Notes"],"tags":[],"redirect_from":["/blog/querying-inside-postgres-json-arrays-260/","/blog/querying-inside-postgres-json-arrays-260"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"querying-inside-postgres-json-arrays"},"buildId":"au-zTTOac9_rvw04kgZaC","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-144e5fa6fafab6397d9c.js"></script><script src="/_next/static/chunks/main-8495f486508069a84016.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" async=""></script><script src="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.b528922461d10cbe9bfe.js" async=""></script><script src="/_next/static/chunks/pages/_app-2f6c726a4c5d3dfd1e8f.js" async=""></script><script src="/_next/static/chunks/0a3463f7b698f32fd7af40216f1292ceb318b3f7.39ce756e4870b72d4174.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-29dccdc32ec4574aab67.js" async=""></script><script src="/_next/static/au-zTTOac9_rvw04kgZaC/_buildManifest.js" async=""></script><script src="/_next/static/au-zTTOac9_rvw04kgZaC/_ssgManifest.js" async=""></script></body></html>