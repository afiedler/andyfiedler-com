<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description" content="Andy Fiedler&#x27;s Personal Site"/><title>Writing Zero-Downtime Migrations for Rails and Postgres</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/588d179d14f543de1f7e.css" as="style"/><link rel="stylesheet" href="/_next/static/css/588d179d14f543de1f7e.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-8495f486508069a84016.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" as="script"/><link rel="preload" href="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.b528922461d10cbe9bfe.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-2f6c726a4c5d3dfd1e8f.js" as="script"/><link rel="preload" href="/_next/static/chunks/0a3463f7b698f32fd7af40216f1292ceb318b3f7.39ce756e4870b72d4174.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/posts/%5Bid%5D-29dccdc32ec4574aab67.js" as="script"/></head><body><div id="__next"><div id="main"><div class="max-w-screen-md mx-auto px-4"><div class="flex items-center justify-between py-6 lg:py-10"><a href="/" class="flex items-center"><p class="font-body font-bold text-2xl text-primary dark:text-white">Andy Fiedler</p></a><div class="flex items-center lg:hidden"><svg width="24" height="15" xmlns="http://www.w3.org/2000/svg" class="fill-current text-primary dark:text-white"><g fill-rule="evenodd"><rect width="24" height="3" rx="1.5"></rect><rect x="8" y="6" width="16" height="3" rx="1.5"></rect><rect x="4" y="12" width="20" height="3" rx="1.5"></rect></g></svg></div><div class="hidden lg:block"><ul class="flex items-center"><li class="mr-6 relative group mb-1"><div class="absolute left-0 bottom-0 w-full transition-all h-0 group-hover:h-2 group-hover:bg-yellow opacity-75 z-20"></div><a href="/posts" class="font-body font-medium text-lg text-primary dark:text-white group-hover:text-green dark:group-hover:text-secondary px-2 z-30 block relative transition-colors">Posts</a></li><li><i class="bx text-3xl text-primary dark:text-white cursor-pointer"></i></li></ul></div><div class="bg-black bg-opacity-80 fixed inset-0 z-20 flex opacity-0 pointer-events-none transition-opacity lg:hidden "><div class="ml-auto bg-blue-600 w-2/3 md:w-1/3 p-4"><svg viewBox="0 0 20 20" width="24" height="24" xmlns="http://www.w3.org/2000/svg" class="fill-current text-white absolute top-0 right-0 mt-4 mr-4"><path d="M15.898,4.045c-0.271-0.272-0.713-0.272-0.986,0l-4.71,4.711L5.493,4.045c-0.272-0.272-0.714-0.272-0.986,0s-0.272,0.714,0,0.986l4.709,4.711l-4.71,4.711c-0.272,0.271-0.272,0.713,0,0.986c0.136,0.136,0.314,0.203,0.492,0.203c0.179,0,0.357-0.067,0.493-0.203l4.711-4.711l4.71,4.711c0.137,0.136,0.314,0.203,0.494,0.203c0.178,0,0.355-0.067,0.492-0.203c0.273-0.273,0.273-0.715,0-0.986l-4.711-4.711l4.711-4.711C16.172,4.759,16.172,4.317,15.898,4.045z"></path></svg><i class="absolute top-0 right-0 mt-4 mr-4"></i><ul class="flex flex-col mt-8"><li class=""><a href="/posts" class="font-body font-medium text-lg text-white px-2 block mb-3">Posts</a></li></ul></div></div></div></div><div class="max-w-screen-md mx-auto px-4"><div class="pt-16 lg:pt-20"><div class="border-b border-grey-lighter pb-8 sm:pb-12"><h2 class="font-body font-semibold text-primary dark:text-white text-3xl sm:text-4xl md:text-5xl block leading-tight">Writing Zero-Downtime Migrations for Rails and Postgres</h2><div class="flex items-center pt-5 sm:pt-8"><p class="font-body font-light text-primary dark:text-white pr-2">2014-04-18 09:38:26 -0400</p></div></div><article class="border-b border-grey-lighter py-8 sm:py-12 prose prose dark:prose-dark max-w-none"><p>Let's suppose you are building an app. It is under heavy development and the dev team is cranking out new features left and right. Developers need to continually change the database schema, but you don't want to take down the app for database migrations if at all possible. How the heck do you do this with Rails?</p>
<p>We had this problem recently, and have come up with a procedure that solves it for most small database migrations. The goals of this procedure are to:</p>
<ul>
	<li>Avoid downtime by running database migrations while the app is live</li>
	<li>Avoid too many separate deployments to production</li>
	<li>Keep the application code as clean as possible</li>
	<li>Balance the cost of additional coding with the benefit of having a zero-downtime migration. If the cost or complexity of coding a migration in this way is too great, then a maintenance window is scheduled and the migration is written in a non-zero downtime fashion.</li>
</ul>
The first thing to understand when writing a zero downtime migration is what types of Postgres data definition language (DDL) queries can be run without locking tables. As of Postgres 9.3, the following DDL queries can be run without locking a table:
<pre class="toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true">CREATE INDEX CONCURRENTLY</pre>
<p style="padding-left: 30px;">Postgres can create indexes concurrently (without table locks) in most cases. <code>CREATE INDEX CONCURRENTLY</code> can take significantly longer than <code>CREATE INDEX</code>, but it will allow both reads and writes while the index is being generated.</p>
<pre class="toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true">ALTER TABLE ... ADD COLUMN -- certain cases only!</pre>
<p style="padding-left: 30px;">You can add a column to a table without a table lock if the column being added is nullable and has no default value or other constraints.</p>
<p style="padding-left: 30px;">If you want to add a column with a constraint or a column with a default value, one option may be to add the column first without a default value and no constraint, then in a separate transaction set the default value (using <code>UPDATE</code>)  or use <code>CREATE INDEX CONCURRENTLY</code> to add a index that will be used for the constraint. Finally, a third transaction can add the constraint or default to the table. If the third transaction is adding a constraint that uses an existing index, no table scan is required.</p>
<pre class="toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true">ALTER TABLE ... DROP COLUMN</pre>
<p style="padding-left: 30px;">Dropping a column only results in a metadata change, so it is non-blocking. When the table is <code>VACUUMED</code>, the data is actually removed.</p>
<pre class="toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true">CREATE TABLE, CREATE FUNCTION</pre>
<p style="padding-left: 30px;">Creating a table or a function is obviously safe because no one will have a lock on these objects before they are created.</p>
<h2>Process for Coding the Migration</h2>
The guidelines I have been using for writing a zero-downtime migration are to:
<ul>
	<li><strong>Step 1: </strong>Write the database migration in Rails.</li>
	<li><strong>Step 2: </strong>Modify the application code in such a way that it will work both before and after the migration has been applied (more details on this below). This will probably entail writing code that branches depending on that database state.</li>
	<li><strong>Step 3: </strong>Run your test suite with the modified code in step 2<i> but before you apply the database migration!</i></li>
	<li><strong>Step 4: </strong>Run your test suite with the modified code in step 2 <em>after applying the database migration</em>. Tests should pass in both cases.</li>
	<li><strong>Step 5: </strong>Create a pull request on Github (or the equivalent in whatever tool you are using). Tag this in such a way that whoever is reviewing your code knows that there is a database migration that needs careful review.</li>
	<li><strong>Step 6: </strong>Create a separate pull request on Github that cleans up the branching code you wrote in step 2. The code you write in this step can assume that the DB is migrated.</li>
</ul>
When the migration is deployed, you'll deploy first the code reviewed in step 5. This code will be running against the non-migrated database, but that is a-ok because you have tested that case in step 3. Next, you will run the migration "live". Once the migration is applied, you will still be running the code reviewed in step 5, but against the migrated database. Again, this is fine because you have tested that in step 4.<strong>
</strong>
<p>Finally, once the production database has been migrated, you should merge your pull request from step 6. This eliminates the dead code supporting the unmigrated version of the database. You should write the code for step 6 at the same time you write the rest of this code. Then just leave the pull request open until you are ready to merge. The advantage of this is that you will be "cleaning up" the extraneous code while it is still fresh in your mind.</p>
<h2>Branching Application Code to Support Multiple DB States</h2>
The key to making this strategy work is that you'll need to write you application code in step 2 in a way that supports two database states: the pre-migrated state and the post-migrated state. The way to do this is to check the database state in the models and branch accordingly.
<p>Suppose you are dropping a column called "deleted". Prior to dropping the column, you have a default scope that excludes deleted rows. After dropping the column, you want the default scope to include all rows.</p>
<p>You would code a migration to do that like this:</p>
<div class="remark-highlight"><pre class="language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">DropDeletedFromPosts</span> <span class="token operator">&#x3C;</span> <span class="token constant">ActiveRecord</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">Migration</span>
   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">up</span></span>
     drop_column <span class="token symbol">:posts</span><span class="token punctuation">,</span> <span class="token symbol">:deleted</span>
   <span class="token keyword">end</span>

   <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">down</span></span>
      add_column <span class="token symbol">:posts</span><span class="token punctuation">,</span> <span class="token symbol">:boolean</span><span class="token punctuation">,</span> <span class="token symbol">:deleted</span><span class="token punctuation">,</span> default<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> null<span class="token punctuation">:</span> <span class="token boolean">false</span>
   <span class="token keyword">end</span>
<span class="token keyword">end</span>
</code></pre></div>
<p>Then, in your Post model, you'd add branching like this:</p>
<div class="remark-highlight"><pre class="language-ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Post</span> <span class="token operator">&#x3C;</span> <span class="token constant">ActiveRecord</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token constant">Base</span>

   <span class="token comment"># TODO: Remove this code after the DropDeletedFromPosts migration has</span>
   <span class="token comment"># been applied.</span>
   <span class="token keyword">if</span> <span class="token constant">Post</span><span class="token punctuation">.</span>attribute_names<span class="token punctuation">.</span><span class="token keyword">include</span><span class="token operator">?</span> <span class="token string">'deleted'</span>
      default_scope <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span> where<span class="token punctuation">(</span>deleted<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
   <span class="token keyword">end</span>

   <span class="token comment"># Other model code here ...</span>

<span class="token keyword">end</span>
</code></pre></div>
<h3> But doesn't this get complicated for larger migrations?</h3>
Yes, absolutely it does. What we do when branching like this and it gets too complicated, we either sequence the DB changes over multiple deployments (and multiple sprints in the Agile sense) or "give up" and schedule a maintenance window (downtime) to do the change.
<p>Writing zero-downtime migrations is not easy, and you'll need to do a cost-benefit analysis between scheduling downtime and writing lots of hairy branching code to support a zero-downtime deploy. That decision will depend on how downtime impacts your customers and your development schedule.</p>
<p>Hopefully, if you decide to go the zero-downtime route, this procedure will make your life easier!</p>
</article></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"writing-zero-downtime-migrations-for-rails-and-postgres","contentHtml":"\u003cp\u003eLet's suppose you are building an app. It is under heavy development and the dev team is cranking out new features left and right. Developers need to continually change the database schema, but you don't want to take down the app for database migrations if at all possible. How the heck do you do this with Rails?\u003c/p\u003e\n\u003cp\u003eWe had this problem recently, and have come up with a procedure that solves it for most small database migrations. The goals of this procedure are to:\u003c/p\u003e\n\u003cul\u003e\n\t\u003cli\u003eAvoid downtime by running database migrations while the app is live\u003c/li\u003e\n\t\u003cli\u003eAvoid too many separate deployments to production\u003c/li\u003e\n\t\u003cli\u003eKeep the application code as clean as possible\u003c/li\u003e\n\t\u003cli\u003eBalance the cost of additional coding with the benefit of having a zero-downtime migration. If the cost or complexity of coding a migration in this way is too great, then a maintenance window is scheduled and the migration is written in a non-zero downtime fashion.\u003c/li\u003e\n\u003c/ul\u003e\nThe first thing to understand when writing a zero downtime migration is what types of Postgres data definition language (DDL) queries can be run without locking tables. As of Postgres 9.3, the following DDL queries can be run without locking a table:\n\u003cpre class=\"toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true\"\u003eCREATE INDEX CONCURRENTLY\u003c/pre\u003e\n\u003cp style=\"padding-left: 30px;\"\u003ePostgres can create indexes concurrently (without table locks) in most cases. \u003ccode\u003eCREATE INDEX CONCURRENTLY\u003c/code\u003e can take significantly longer than \u003ccode\u003eCREATE INDEX\u003c/code\u003e, but it will allow both reads and writes while the index is being generated.\u003c/p\u003e\n\u003cpre class=\"toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true\"\u003eALTER TABLE ... ADD COLUMN -- certain cases only!\u003c/pre\u003e\n\u003cp style=\"padding-left: 30px;\"\u003eYou can add a column to a table without a table lock if the column being added is nullable and has no default value or other constraints.\u003c/p\u003e\n\u003cp style=\"padding-left: 30px;\"\u003eIf you want to add a column with a constraint or a column with a default value, one option may be to add the column first without a default value and no constraint, then in a separate transaction set the default value (using \u003ccode\u003eUPDATE\u003c/code\u003e)  or use \u003ccode\u003eCREATE INDEX CONCURRENTLY\u003c/code\u003e to add a index that will be used for the constraint. Finally, a third transaction can add the constraint or default to the table. If the third transaction is adding a constraint that uses an existing index, no table scan is required.\u003c/p\u003e\n\u003cpre class=\"toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true\"\u003eALTER TABLE ... DROP COLUMN\u003c/pre\u003e\n\u003cp style=\"padding-left: 30px;\"\u003eDropping a column only results in a metadata change, so it is non-blocking. When the table is \u003ccode\u003eVACUUMED\u003c/code\u003e, the data is actually removed.\u003c/p\u003e\n\u003cpre class=\"toolbar:2 nums:false nums-toggle:false lang:pgsql decode:true\"\u003eCREATE TABLE, CREATE FUNCTION\u003c/pre\u003e\n\u003cp style=\"padding-left: 30px;\"\u003eCreating a table or a function is obviously safe because no one will have a lock on these objects before they are created.\u003c/p\u003e\n\u003ch2\u003eProcess for Coding the Migration\u003c/h2\u003e\nThe guidelines I have been using for writing a zero-downtime migration are to:\n\u003cul\u003e\n\t\u003cli\u003e\u003cstrong\u003eStep 1: \u003c/strong\u003eWrite the database migration in Rails.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eStep 2: \u003c/strong\u003eModify the application code in such a way that it will work both before and after the migration has been applied (more details on this below). This will probably entail writing code that branches depending on that database state.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eStep 3: \u003c/strong\u003eRun your test suite with the modified code in step 2\u003ci\u003e but before you apply the database migration!\u003c/i\u003e\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eStep 4: \u003c/strong\u003eRun your test suite with the modified code in step 2 \u003cem\u003eafter applying the database migration\u003c/em\u003e. Tests should pass in both cases.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eStep 5: \u003c/strong\u003eCreate a pull request on Github (or the equivalent in whatever tool you are using). Tag this in such a way that whoever is reviewing your code knows that there is a database migration that needs careful review.\u003c/li\u003e\n\t\u003cli\u003e\u003cstrong\u003eStep 6: \u003c/strong\u003eCreate a separate pull request on Github that cleans up the branching code you wrote in step 2. The code you write in this step can assume that the DB is migrated.\u003c/li\u003e\n\u003c/ul\u003e\nWhen the migration is deployed, you'll deploy first the code reviewed in step 5. This code will be running against the non-migrated database, but that is a-ok because you have tested that case in step 3. Next, you will run the migration \"live\". Once the migration is applied, you will still be running the code reviewed in step 5, but against the migrated database. Again, this is fine because you have tested that in step 4.\u003cstrong\u003e\n\u003c/strong\u003e\n\u003cp\u003eFinally, once the production database has been migrated, you should merge your pull request from step 6. This eliminates the dead code supporting the unmigrated version of the database. You should write the code for step 6 at the same time you write the rest of this code. Then just leave the pull request open until you are ready to merge. The advantage of this is that you will be \"cleaning up\" the extraneous code while it is still fresh in your mind.\u003c/p\u003e\n\u003ch2\u003eBranching Application Code to Support Multiple DB States\u003c/h2\u003e\nThe key to making this strategy work is that you'll need to write you application code in step 2 in a way that supports two database states: the pre-migrated state and the post-migrated state. The way to do this is to check the database state in the models and branch accordingly.\n\u003cp\u003eSuppose you are dropping a column called \"deleted\". Prior to dropping the column, you have a default scope that excludes deleted rows. After dropping the column, you want the default scope to include all rows.\u003c/p\u003e\n\u003cp\u003eYou would code a migration to do that like this:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-ruby\"\u003e\u003ccode class=\"language-ruby\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003eDropDeletedFromPosts\u003c/span\u003e \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e \u003cspan class=\"token constant\"\u003eActiveRecord\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\u003cspan class=\"token constant\"\u003eMigration\u003c/span\u003e\n   \u003cspan class=\"token keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"token method-definition\"\u003e\u003cspan class=\"token function\"\u003eup\u003c/span\u003e\u003c/span\u003e\n     drop_column \u003cspan class=\"token symbol\"\u003e:posts\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token symbol\"\u003e:deleted\u003c/span\u003e\n   \u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\n   \u003cspan class=\"token keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"token method-definition\"\u003e\u003cspan class=\"token function\"\u003edown\u003c/span\u003e\u003c/span\u003e\n      add_column \u003cspan class=\"token symbol\"\u003e:posts\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token symbol\"\u003e:boolean\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e \u003cspan class=\"token symbol\"\u003e:deleted\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e default\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token boolean\"\u003efalse\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e,\u003c/span\u003e null\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token boolean\"\u003efalse\u003c/span\u003e\n   \u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThen, in your Post model, you'd add branching like this:\u003c/p\u003e\n\u003cdiv class=\"remark-highlight\"\u003e\u003cpre class=\"language-ruby\"\u003e\u003ccode class=\"language-ruby\"\u003e\u003cspan class=\"token keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"token class-name\"\u003ePost\u003c/span\u003e \u003cspan class=\"token operator\"\u003e\u0026#x3C;\u003c/span\u003e \u003cspan class=\"token constant\"\u003eActiveRecord\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e\u003cspan class=\"token constant\"\u003eBase\u003c/span\u003e\n\n   \u003cspan class=\"token comment\"\u003e# TODO: Remove this code after the DropDeletedFromPosts migration has\u003c/span\u003e\n   \u003cspan class=\"token comment\"\u003e# been applied.\u003c/span\u003e\n   \u003cspan class=\"token keyword\"\u003eif\u003c/span\u003e \u003cspan class=\"token constant\"\u003ePost\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003eattribute_names\u003cspan class=\"token punctuation\"\u003e.\u003c/span\u003e\u003cspan class=\"token keyword\"\u003einclude\u003c/span\u003e\u003cspan class=\"token operator\"\u003e?\u003c/span\u003e \u003cspan class=\"token string\"\u003e'deleted'\u003c/span\u003e\n      default_scope \u003cspan class=\"token operator\"\u003e-\u003c/span\u003e\u003cspan class=\"token operator\"\u003e\u003e\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e{\u003c/span\u003e where\u003cspan class=\"token punctuation\"\u003e(\u003c/span\u003edeleted\u003cspan class=\"token punctuation\"\u003e:\u003c/span\u003e \u003cspan class=\"token boolean\"\u003efalse\u003c/span\u003e\u003cspan class=\"token punctuation\"\u003e)\u003c/span\u003e \u003cspan class=\"token punctuation\"\u003e}\u003c/span\u003e\n   \u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\n   \u003cspan class=\"token comment\"\u003e# Other model code here ...\u003c/span\u003e\n\n\u003cspan class=\"token keyword\"\u003eend\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003e But doesn't this get complicated for larger migrations?\u003c/h3\u003e\nYes, absolutely it does. What we do when branching like this and it gets too complicated, we either sequence the DB changes over multiple deployments (and multiple sprints in the Agile sense) or \"give up\" and schedule a maintenance window (downtime) to do the change.\n\u003cp\u003eWriting zero-downtime migrations is not easy, and you'll need to do a cost-benefit analysis between scheduling downtime and writing lots of hairy branching code to support a zero-downtime deploy. That decision will depend on how downtime impacts your customers and your development schedule.\u003c/p\u003e\n\u003cp\u003eHopefully, if you decide to go the zero-downtime route, this procedure will make your life easier!\u003c/p\u003e\n","layout":"post","status":"publish","published":true,"title":"Writing Zero-Downtime Migrations for Rails and Postgres","author":{"display_name":"afiedler","login":"afiedler","email":"andy@andyfiedler.com","url":""},"author_login":"afiedler","author_email":"andy@andyfiedler.com","wordpress_id":265,"wordpress_url":"http://andyfiedler.com/?p=265","date":"2014-04-18 09:38:26 -0400","date_gmt":"2014-04-18 13:38:26 -0400","categories":["Tech Notes"],"tags":["postgres","rails"],"redirect_from":["/blog/writing-zero-downtime-migrations-for-rails-and-postgres-265/","/blog/writing-zero-downtime-migrations-for-rails-and-postgres-265"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"writing-zero-downtime-migrations-for-rails-and-postgres"},"buildId":"kin1HMdhXCenXl5fEijbK","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-144e5fa6fafab6397d9c.js"></script><script src="/_next/static/chunks/main-8495f486508069a84016.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.abffcf18e526b7c0dbcd.js" async=""></script><script src="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.b528922461d10cbe9bfe.js" async=""></script><script src="/_next/static/chunks/pages/_app-2f6c726a4c5d3dfd1e8f.js" async=""></script><script src="/_next/static/chunks/0a3463f7b698f32fd7af40216f1292ceb318b3f7.39ce756e4870b72d4174.js" async=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-29dccdc32ec4574aab67.js" async=""></script><script src="/_next/static/kin1HMdhXCenXl5fEijbK/_buildManifest.js" async=""></script><script src="/_next/static/kin1HMdhXCenXl5fEijbK/_ssgManifest.js" async=""></script></body></html>