<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description" content="Andy Fiedler&#x27;s Personal Site"/><title>NodeJS and Hapi for Rails Developers</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/2ebc4650f8bf19a5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2ebc4650f8bf19a5.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-0d72f87c7081bf6b.js" defer=""></script><script src="/_next/static/chunks/main-c1f318e46964e3b2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a8fa0b8d60e9233f.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-5774d63731fac027.js" defer=""></script><script src="/_next/static/GZkcVq_osIziEGIGcZx-5/_buildManifest.js" defer=""></script><script src="/_next/static/GZkcVq_osIziEGIGcZx-5/_ssgManifest.js" defer=""></script><script src="/_next/static/GZkcVq_osIziEGIGcZx-5/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div id="main"><div class="max-w-screen-md mx-auto px-4"><div class="flex items-center justify-between py-6 lg:py-10"><a href="/" class="flex items-center"><p class="font-body font-bold text-2xl text-primary dark:text-white">Andy Fiedler</p></a><div class="flex items-center lg:hidden"><svg width="24" height="15" xmlns="http://www.w3.org/2000/svg" class="fill-current text-primary dark:text-white"><g fill-rule="evenodd"><rect width="24" height="3" rx="1.5"></rect><rect x="8" y="6" width="16" height="3" rx="1.5"></rect><rect x="4" y="12" width="20" height="3" rx="1.5"></rect></g></svg></div><div class="hidden lg:block"><ul class="flex items-center"><li class="mr-6 relative group mb-1"><div class="absolute left-0 bottom-0 w-full transition-all h-0 group-hover:h-2 group-hover:bg-yellow opacity-75 z-20"></div><a href="/posts" class="font-body font-medium text-lg text-primary dark:text-white group-hover:text-green dark:group-hover:text-secondary px-2 z-30 block relative transition-colors">Posts</a></li><li><i class="bx text-3xl text-primary dark:text-white cursor-pointer"></i></li></ul></div><div class="bg-black bg-opacity-80 fixed inset-0 z-20 flex opacity-0 pointer-events-none transition-opacity lg:hidden "><div class="ml-auto bg-blue-600 w-2/3 md:w-1/3 p-4"><svg viewBox="0 0 20 20" width="24" height="24" xmlns="http://www.w3.org/2000/svg" class="fill-current text-white absolute top-0 right-0 mt-4 mr-4"><path d="M15.898,4.045c-0.271-0.272-0.713-0.272-0.986,0l-4.71,4.711L5.493,4.045c-0.272-0.272-0.714-0.272-0.986,0s-0.272,0.714,0,0.986l4.709,4.711l-4.71,4.711c-0.272,0.271-0.272,0.713,0,0.986c0.136,0.136,0.314,0.203,0.492,0.203c0.179,0,0.357-0.067,0.493-0.203l4.711-4.711l4.71,4.711c0.137,0.136,0.314,0.203,0.494,0.203c0.178,0,0.355-0.067,0.492-0.203c0.273-0.273,0.273-0.715,0-0.986l-4.711-4.711l4.711-4.711C16.172,4.759,16.172,4.317,15.898,4.045z"></path></svg><i class="absolute top-0 right-0 mt-4 mr-4"></i><ul class="flex flex-col mt-8"><li class=""><a href="/posts" class="font-body font-medium text-lg text-white px-2 block mb-3">Posts</a></li></ul></div></div></div></div><div class="max-w-screen-md mx-auto px-4"><div class="pt-16 lg:pt-20"><div class="border-b border-grey-lighter pb-8 sm:pb-12"><h2 class="font-body font-semibold text-primary dark:text-white text-3xl sm:text-4xl md:text-5xl block leading-tight">NodeJS and Hapi for Rails Developers</h2><div class="flex items-center pt-5 sm:pt-8"><p class="font-body font-light text-primary dark:text-white pr-2">2015-07-22 09:59:48 -0400</p></div></div><article class="border-b border-grey-lighter py-8 sm:py-12 prose prose dark:prose-dark max-w-none"><p>This post is an <strong>work in progress</strong> list of tips and tricks I've learned working on a HapiJS API after mostly coding Rails APIs for the last few years. I expect to update it as I learn more.</p>
<p>If you are a Rails developer looking to transition to NodeJS, hopefully this will save you some time. If you are a more seasoned NodeJS or Hapi developer and have suggestions for improving this, please let me know in the comments.</p>
<h2>Async Programming</h2>
<h3>Error-first callbacks, promises, or <code>async</code>/<code>await</code></h3>
<p>Most Rails developers have written some Javascript, so you are probably familiar with callbacks. On the client, having nested callbacks is relatively rare. On the server, however, they are far more common. A simple example would be a server method that needs to make a handful of database calls, with all of the depending on the outcome of the others. This would be trivial to write in a sequential way, but with NodeJS, you will need to nest callbacks to accomplish the same thing.</p>
<p>This is both the best thing about NodeJS and the most annoying. It makes things very performant, because with callbacks you continually return control to the main event loop, freeing the main thread to move on to other things. In Rails, unless you are using a threaded server like Puma, waiting on a database call will block the entire process.</p>
<p>All of Node core and most of the libraries use error-first callbacks. If the first argument to the callback function is truthy, then you know the callback has failed with an error. You'll see a lot of code in NodeJS like this:</p>
<div><pre><code><span>var</span> <span>myCallbackFunction</span> <span>=</span> <span>function</span><span>(</span>options<span>,</span> <span>function</span><span>(</span><span>err<span>,</span> result</span><span>)</span> <span>{</span>
   <span>if</span><span>(</span>err<span>)</span> <span>return</span> err<span>;</span>
   <span>// process the result</span>
<span>}</span><span>)</span><span>;</span>
</code></pre></div>
<p>This gets nasty when you have many nested callbacks and has been dubbed "callback hell".</p>
<p>One way to fix this is to use a promise. You can typically turn any error-first callback function into a promise-returning function with <code>Promise.promisify()</code>.</p>
<div><pre><code><span>var</span> <span>Promise</span> <span>=</span> <span>require</span><span>(</span><span>'bluebird'</span><span>)</span><span>;</span> <span>// bluebird is a popular promise library</span>
<span>var</span> myAsyncFunction <span>=</span> <span>Promise</span><span>.</span><span>promisify</span><span>(</span>myCallbackFunction<span>)</span><span>;</span>

<span>myAsyncFunction</span><span>(</span>options<span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>result</span><span>)</span> <span>{</span>
   <span>// process result</span>
<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
   <span>// process error</span>
<span>}</span><span>)</span><span>;</span>
</code></pre></div>
<p>This doesn't look Earth-shattering, but promises can make deeply nested callbacks more readable. I like promises from my AngularJS programming, but they aren't widely used in the Node community. If you attempt to use them, you feel like you are fighting an uphill battle since everyone still uses error-first callbacks. They can be vital in some situations, however.</p>
<h4>ES7 and <code>async</code>/<code>await</code></h4>
<p>The next generation of Javascript will hopefully solve all of our problems with the addition of two new keywords: <code>async</code> and <code>await</code>. These use promises under the hood, but you can use <code>try</code>-<code>catch</code> and don't need <code>then()</code>:</p>
<div><pre><code><span>try</span> <span>{</span>
   <span>var</span> result <span>=</span> <span>await</span> <span>myAsyncFunction</span><span>(</span>options<span>)</span><span>;</span>
   <span>// process result</span>
<span>}</span> <span>catch</span> <span>(</span>ex<span>)</span> <span>{</span>
   <span>// handle error</span>
<span>}</span>
</code></pre></div>
<p>You can use this today if you transpile with the Traceur compiler, but not much of the Node community is doing that yet. Once more people get on board, this will be a <em>huge</em> improvement in Javascript.</p>
<h4>What do do today?</h4>
<p>Today, I think you should stick with error-first callbacks and use promises if absolutely necessary. Another library you can look into is the <a href="https://github.com/caolan/async"><code>async</code></a> library, which gives you lots of nice functions to handle many callbacks in series or parallel.</p>
<h2>Unit Testing</h2>
<h3>NPM packages to use</h3>
<ul>
<li><a href="https://github.com/hapijs/lab">Lab</a> - Hapi's unit testing framework. It supports both TestUnit and RSpec style tests. I'm using the RSpec style.</li>
<li><a href="https://github.com/hapijs/code">Code</a> - An assertion library. This handles <code>expect</code> statements. There are a <a href="http://andyfiedler.com/blog/gotchas-with-hapis-code-library-327/">few gotchas</a>.</li>
</ul>
<h3>Test folder setup</h3>
<p>I'm using RSpec style tests, so my folder hierarchy looks like this:</p>
<div><pre><code>+ /
|
+---specs
|
+---requests
| |
| +---users
| |
| +---get.js
|
+---models
|
+---user.js</code></pre></div>
<h3>Running your specs</h3>
<p>To run your specs, you have two choices. You can either install lab globally and run them with the <code>lab</code> command, or you can change your <code>package.json</code> file to set what to run for <code>npm test</code>. I usually do the second options, because it lets me specify some default options for lab. Here's what the section of <code>package.json</code> file looks like:</p>
<div><pre><code><span>{</span>
   <span>"scripts"</span><span>:</span> <span>{</span>
      <span>"test"</span><span>:</span> <span>"env $(cat .env | xargs) lab -v -L -m 0"</span>
   <span>}</span>
<span>}</span>
</code></pre></div>
<p>The <code>xargs</code> part is to set the environmental variables before running the tests from the <code>.env</code> file. There probably is a better way to do this, but that is working for now.</p>
</article></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"nodejs-and-hapi-for-rails-developers","contentHtml":"\u003cp\u003eThis post is an \u003cstrong\u003ework in progress\u003c/strong\u003e list of tips and tricks I've learned working on a HapiJS API after mostly coding Rails APIs for the last few years. I expect to update it as I learn more.\u003c/p\u003e\n\u003cp\u003eIf you are a Rails developer looking to transition to NodeJS, hopefully this will save you some time. If you are a more seasoned NodeJS or Hapi developer and have suggestions for improving this, please let me know in the comments.\u003c/p\u003e\n\u003ch2\u003eAsync Programming\u003c/h2\u003e\n\u003ch3\u003eError-first callbacks, promises, or \u003ccode\u003easync\u003c/code\u003e/\u003ccode\u003eawait\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eMost Rails developers have written some Javascript, so you are probably familiar with callbacks. On the client, having nested callbacks is relatively rare. On the server, however, they are far more common. A simple example would be a server method that needs to make a handful of database calls, with all of the depending on the outcome of the others. This would be trivial to write in a sequential way, but with NodeJS, you will need to nest callbacks to accomplish the same thing.\u003c/p\u003e\n\u003cp\u003eThis is both the best thing about NodeJS and the most annoying. It makes things very performant, because with callbacks you continually return control to the main event loop, freeing the main thread to move on to other things. In Rails, unless you are using a threaded server like Puma, waiting on a database call will block the entire process.\u003c/p\u003e\n\u003cp\u003eAll of Node core and most of the libraries use error-first callbacks. If the first argument to the callback function is truthy, then you know the callback has failed with an error. You'll see a lot of code in NodeJS like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003emyCallbackFunction\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eoptions\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerr\u003cspan\u003e,\u003c/span\u003e result\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003eif\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eerr\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e err\u003cspan\u003e;\u003c/span\u003e\n   \u003cspan\u003e// process the result\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis gets nasty when you have many nested callbacks and has been dubbed \"callback hell\".\u003c/p\u003e\n\u003cp\u003eOne way to fix this is to use a promise. You can typically turn any error-first callback function into a promise-returning function with \u003ccode\u003ePromise.promisify()\u003c/code\u003e.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003evar\u003c/span\u003e \u003cspan\u003ePromise\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003erequire\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e'bluebird'\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// bluebird is a popular promise library\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e myAsyncFunction \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003ePromise\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003epromisify\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003emyCallbackFunction\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003emyAsyncFunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eoptions\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ethen\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eresult\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003e// process result\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003ecatch\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eerr\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003e// process error\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThis doesn't look Earth-shattering, but promises can make deeply nested callbacks more readable. I like promises from my AngularJS programming, but they aren't widely used in the Node community. If you attempt to use them, you feel like you are fighting an uphill battle since everyone still uses error-first callbacks. They can be vital in some situations, however.\u003c/p\u003e\n\u003ch4\u003eES7 and \u003ccode\u003easync\u003c/code\u003e/\u003ccode\u003eawait\u003c/code\u003e\u003c/h4\u003e\n\u003cp\u003eThe next generation of Javascript will hopefully solve all of our problems with the addition of two new keywords: \u003ccode\u003easync\u003c/code\u003e and \u003ccode\u003eawait\u003c/code\u003e. These use promises under the hood, but you can use \u003ccode\u003etry\u003c/code\u003e-\u003ccode\u003ecatch\u003c/code\u003e and don't need \u003ccode\u003ethen()\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003etry\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003evar\u003c/span\u003e result \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003eawait\u003c/span\u003e \u003cspan\u003emyAsyncFunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003eoptions\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n   \u003cspan\u003e// process result\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e \u003cspan\u003ecatch\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003eex\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003e// handle error\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eYou can use this today if you transpile with the Traceur compiler, but not much of the Node community is doing that yet. Once more people get on board, this will be a \u003cem\u003ehuge\u003c/em\u003e improvement in Javascript.\u003c/p\u003e\n\u003ch4\u003eWhat do do today?\u003c/h4\u003e\n\u003cp\u003eToday, I think you should stick with error-first callbacks and use promises if absolutely necessary. Another library you can look into is the \u003ca href=\"https://github.com/caolan/async\"\u003e\u003ccode\u003easync\u003c/code\u003e\u003c/a\u003e library, which gives you lots of nice functions to handle many callbacks in series or parallel.\u003c/p\u003e\n\u003ch2\u003eUnit Testing\u003c/h2\u003e\n\u003ch3\u003eNPM packages to use\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/hapijs/lab\"\u003eLab\u003c/a\u003e - Hapi's unit testing framework. It supports both TestUnit and RSpec style tests. I'm using the RSpec style.\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/hapijs/code\"\u003eCode\u003c/a\u003e - An assertion library. This handles \u003ccode\u003eexpect\u003c/code\u003e statements. There are a \u003ca href=\"http://andyfiedler.com/blog/gotchas-with-hapis-code-library-327/\"\u003efew gotchas\u003c/a\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eTest folder setup\u003c/h3\u003e\n\u003cp\u003eI'm using RSpec style tests, so my folder hierarchy looks like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e+ /\n|\n+---specs\n|\n+---requests\n| |\n| +---users\n| |\n| +---get.js\n|\n+---models\n|\n+---user.js\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003eRunning your specs\u003c/h3\u003e\n\u003cp\u003eTo run your specs, you have two choices. You can either install lab globally and run them with the \u003ccode\u003elab\u003c/code\u003e command, or you can change your \u003ccode\u003epackage.json\u003c/code\u003e file to set what to run for \u003ccode\u003enpm test\u003c/code\u003e. I usually do the second options, because it lets me specify some default options for lab. Here's what the section of \u003ccode\u003epackage.json\u003c/code\u003e file looks like:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003e\"scripts\"\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n      \u003cspan\u003e\"test\"\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e\"env $(cat .env | xargs) lab -v -L -m 0\"\u003c/span\u003e\n   \u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003exargs\u003c/code\u003e part is to set the environmental variables before running the tests from the \u003ccode\u003e.env\u003c/code\u003e file. There probably is a better way to do this, but that is working for now.\u003c/p\u003e\n","layout":"post","status":"publish","published":true,"title":"NodeJS and Hapi for Rails Developers","author":{"display_name":"afiedler","login":"afiedler","email":"andy@andyfiedler.com","url":""},"author_login":"afiedler","author_email":"andy@andyfiedler.com","wordpress_id":324,"wordpress_url":"http://andyfiedler.com/?p=324","date":"2015-07-22 09:59:48 -0400","date_gmt":"2015-07-22 13:59:48 -0400","categories":["Tech Notes"],"tags":["rails","nodejs","hapi"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"nodejs-and-hapi-for-rails-developers"},"buildId":"GZkcVq_osIziEGIGcZx-5","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>