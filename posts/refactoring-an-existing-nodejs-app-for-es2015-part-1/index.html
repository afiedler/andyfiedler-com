<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><meta name="description" content="Andy Fiedler&#x27;s Personal Site"/><title>Refactoring an Existing NodeJS App for ES2015 (Part 1)</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/3a91f8daa0490311.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3a91f8daa0490311.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-0d72f87c7081bf6b.js" defer=""></script><script src="/_next/static/chunks/main-c1f318e46964e3b2.js" defer=""></script><script src="/_next/static/chunks/pages/_app-a8fa0b8d60e9233f.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-6b928787a3b50cea.js" defer=""></script><script src="/_next/static/Jjjk-tfnOMqoXTjgl9oWU/_buildManifest.js" defer=""></script><script src="/_next/static/Jjjk-tfnOMqoXTjgl9oWU/_ssgManifest.js" defer=""></script><script src="/_next/static/Jjjk-tfnOMqoXTjgl9oWU/_middlewareManifest.js" defer=""></script></head><body><div id="__next"><div id="main"><div class="max-w-screen-md mx-auto px-4"><div class="flex items-center justify-between py-6 lg:py-10"><a href="/" class="flex items-center"><p class="font-body font-bold text-2xl text-primary dark:text-white">Andy Fiedler</p></a><div class="flex items-center lg:hidden"><svg width="24" height="15" xmlns="http://www.w3.org/2000/svg" class="fill-current text-primary dark:text-white"><g fill-rule="evenodd"><rect width="24" height="3" rx="1.5"></rect><rect x="8" y="6" width="16" height="3" rx="1.5"></rect><rect x="4" y="12" width="20" height="3" rx="1.5"></rect></g></svg></div><div class="hidden lg:block"><ul class="flex items-center"><li class="mr-6 relative group mb-1"><div class="absolute left-0 bottom-0 w-full transition-all h-0 group-hover:h-2 group-hover:bg-yellow opacity-75 z-20"></div><a href="/posts" class="font-body font-medium text-lg text-primary dark:text-white group-hover:text-green dark:group-hover:text-secondary px-2 z-30 block relative transition-colors">Posts</a></li><li><i class="bx text-3xl text-primary dark:text-white cursor-pointer"></i></li></ul></div><div class="bg-black bg-opacity-80 fixed inset-0 z-20 flex opacity-0 pointer-events-none transition-opacity lg:hidden "><div class="ml-auto bg-blue-600 w-2/3 md:w-1/3 p-4"><svg viewBox="0 0 20 20" width="24" height="24" xmlns="http://www.w3.org/2000/svg" class="fill-current text-white absolute top-0 right-0 mt-4 mr-4"><path d="M15.898,4.045c-0.271-0.272-0.713-0.272-0.986,0l-4.71,4.711L5.493,4.045c-0.272-0.272-0.714-0.272-0.986,0s-0.272,0.714,0,0.986l4.709,4.711l-4.71,4.711c-0.272,0.271-0.272,0.713,0,0.986c0.136,0.136,0.314,0.203,0.492,0.203c0.179,0,0.357-0.067,0.493-0.203l4.711-4.711l4.71,4.711c0.137,0.136,0.314,0.203,0.494,0.203c0.178,0,0.355-0.067,0.492-0.203c0.273-0.273,0.273-0.715,0-0.986l-4.711-4.711l4.711-4.711C16.172,4.759,16.172,4.317,15.898,4.045z"></path></svg><i class="absolute top-0 right-0 mt-4 mr-4"></i><ul class="flex flex-col mt-8"><li class=""><a href="/posts" class="font-body font-medium text-lg text-white px-2 block mb-3">Posts</a></li></ul></div></div></div></div><div class="max-w-screen-md mx-auto px-4"><div class="pt-16 lg:pt-20"><div class="border-b border-grey-lighter pb-8 sm:pb-12"><h2 class="font-body font-semibold text-primary dark:text-white text-3xl sm:text-4xl md:text-5xl block leading-tight">Refactoring an Existing NodeJS App for ES2015 (Part 1)</h2><div class="flex items-center pt-5 sm:pt-8"><p class="font-body font-light text-primary dark:text-white pr-2">2016-01-13 11:12:53 -0500</p></div></div><article class="border-b border-grey-lighter py-8 sm:py-12 prose prose dark:prose-dark max-w-none"><p>Thinking of getting started with ES2015? Coding with NodeJS v5.0.0 or higher? You can get started today! Node supports many features of ES2015 natively, without the need for a transpiler like Babel or Traceur.</p>
<p>ES2015 actually has a <em>lot</em> of really awesome features, and I think most of them are worthwhile to start using eventually. But, it you already have a Node app written and want to introduce ES2015 gradually, which features should you pick first?</p>
<p>This post talks about the three ES2015 features that I would focus on first. I picked these because they are the most compatible with existing patterns and are the easiest for developers to pick up and start using right away. They are also all supported fully in Node 5.x.</p>
<p>The features are:</p>
<ol>
<li>Block-scoped declarations (<code>let</code> and <code>const</code>)</li>
<li>Arrow functions</li>
<li>Template strings and new <code>String</code> methods</li>
</ol>
<p>Part 2 will of this series will talk about classes.</p>
<h2>Start using block-scoped variable declarations (<code>let</code> and <code>const</code>) instead of <code>var</code></h2>
<p><strong>Note:</strong> You need to be in strict mode (<code>'use strict'</code>) for these keywords to work. If you are using the Node REPL, you need to start it with <code>node --use_strict</code> as opposed to typing <code>'use strict';</code> within the REPL.</p>
<h3>What is this <code>let</code> business?</h3>
<p>The <code>var</code> keyword has a few issues that have been corrected by the new <code>let</code> keyword. First of all, <code>var</code> may be hoisted like this:</p>
<div><pre><code>bla <span>=</span> <span>2</span><span>;</span>
<span>var</span> bla<span>;</span>

<span>// is identical to:</span>
<span>var</span> bla<span>;</span>
bla <span>=</span> <span>2</span><span>;</span>
</code></pre></div>
<p>Second of all, <code>var</code>-defined variables have the scope of <em>entire</em> enclosing function.</p>
<div><pre><code><span>function</span> <span>varExample</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> x <span>=</span> <span>1</span><span>;</span>
  <span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
    <span>var</span> x <span>=</span> <span>2</span><span>;</span>  <span>// same variable!</span>
    <span>console</span><span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>  <span>// 2</span>
  <span>}</span>
  <span>console</span><span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>  <span>// 2</span>
<span>}</span>
</code></pre></div>
<p>The <code>let</code> keyword avoids all of this weirdness. When you use <code>let</code> there is no hoisting, so you will get a ReferenceError at runtime:</p>
<div><pre><code><span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span>
   c <span>=</span> <span>1</span><span>;</span>
   <span>let</span> c <span>=</span> <span>2</span><span>;</span>
   <span>return</span> c<span>;</span>
<span>}</span>
<span>a</span><span>(</span><span>)</span><span>;</span> <span>// ReferenceError: c is not defined</span>
</code></pre></div>
<p>Variables declared with <code>let</code> are block-scoped, not function scoped. A block is any section of code delimited with <code>{ ... }</code>. Here's an example:</p>
<div><pre><code><span>let</span> x <span>=</span> <span>1</span><span>;</span>
<span>let</span> y <span>=</span> <span>2</span><span>;</span>
<span>if</span> <span>(</span>y <span>></span> x<span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>3</span><span>;</span>
  x <span>=</span> a<span>;</span>
<span>}</span>
<span>console</span><span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span> <span>// 3</span>
<span>console</span><span>.</span><span>log</span><span>(</span>y<span>)</span><span>;</span> <span>// 2</span>
<span>console</span><span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>// ReferenceError: a is not defined.</span>
</code></pre></div>
<h3>What about <code>const</code>?</h3>
<p>The <code>const</code> keyword follows the same scoping and (non-) hoisting rules as <code>let</code>. It has one more constraint, though: variables declared with <code>const</code> don't change their reference.</p>
<p>Here's a few examples:</p>
<div><pre><code><span>const</span> <span>A</span> <span>=</span> <span>1</span><span>;</span>
<span>A</span> <span>=</span> <span>2</span><span>;</span>   <span>// TypeError: assignment to a constant variable</span>
</code></pre></div>
<p>It's also important to realize that <code>const</code> doesn't enforce immutability for objects. You <em>can</em> change object properties of objects declared with <code>const</code>:</p>
<div><pre><code><span>'use strict'</span><span>;</span>
<span>const</span> <span>MY_OBJECT</span> <span>=</span> <span>{</span>
   <span>MyProp</span><span>:</span> <span>1</span>
<span>}</span><span>;</span>
<span>MY_OBJECT</span><span>.</span><span><span>MyProp</span></span> <span>=</span> <span>2</span><span>;</span> <span>// no error here!</span>
<span>console</span><span>.</span><span>log</span><span>(</span><span>MY_OBJECT</span><span>.</span><span><span>MyProp</span></span><span>)</span><span>;</span> <span>// 2</span>
</code></pre></div>
<h3>Refactoring recommendation</h3>
<blockquote>
<p>If it is possible to use <code>const</code>, use it. If it isn't possible to use <code>const</code>, use <code>let</code>. Don't use <code>var</code> anymore, unless you find some crazy edge-case where it is necessary.</p>
</blockquote>
<h2>Arrow functions</h2>
<p>Arrow functions are a shorthand for writing small, anonymous functions. They also adopt the scope of their surrounding code, rather than creating a new one. This can eliminate use of the <code>var self = this;</code> pattern, and eliminate some uses of <code>.bind()</code>.</p>
<p>Arrow functions also have a further-shortened version for implicitly returning the value of an expression. This is great for iterators and lodash-style functional programming.</p>
<p>Here are some examples:</p>
<div><pre><code><span>let</span> myArray <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>
<span>// These are all equivalent:</span>
myArray<span>.</span><span>map</span><span>(</span><span>function</span><span>(</span><span>i</span><span>)</span> <span>{</span> <span>return</span> i <span>+</span> <span>1</span><span>;</span> <span>}</span><span>)</span>
myArray<span>.</span><span>map</span><span>(</span><span>(</span><span>i</span><span>)</span> <span>=></span> <span>{</span> <span>return</span> i <span>+</span> <span>1</span><span>;</span> <span>}</span><span>)</span><span>;</span>
myArray<span>.</span><span>map</span><span>(</span><span>(</span><span>i</span><span>)</span> <span>=></span> <span>{</span> i <span>+</span> <span>1</span><span>;</span> <span>}</span><span>)</span><span>;</span>
myArray<span>.</span><span>map</span><span>(</span><span>(</span><span>i</span><span>)</span> <span>=></span> <span>(</span>i <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>
myArray<span>.</span><span>map</span><span>(</span><span>(</span><span>i</span><span>)</span> <span>=></span> i <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// expression (i + 1) must be on one line</span>
myArray<span>.</span><span>map</span><span>(</span><span>i</span> <span>=></span> i <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// also must be on one line</span>
<span>// all return [2, 3, 4]</span>
</code></pre></div>
<p>Here's an example of the way <code>this</code> works with arrow functions:</p>
<div><pre><code><span>function</span> <span><span>Person</span></span> <span>(</span><span>)</span> <span>{</span>
   <span>this</span><span>.</span><span>age</span> <span>=</span> <span>0</span><span>;</span>
   <span>setInterval</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span> <span>this</span><span>.</span><span>age</span><span>++</span><span>;</span> <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
<span>}</span>
<span>let</span> p <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
p<span>.</span><span>age</span><span>;</span> <span>// -> 0</span>
<span>// (wait a few seconds)</span>
p<span>.</span><span>age</span><span>;</span> <span>// -> still 0</span>
</code></pre></div>
<p>You could fix this with <code>self</code>, but that is annoying. Arrow functions make this easier:</p>
<div><pre><code><span>function</span> <span><span>Person</span></span><span>(</span><span>)</span> <span>{</span>
   <span>this</span><span>.</span><span>age</span> <span>=</span> <span>0</span><span>;</span>
   <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span> <span>this</span><span>.</span><span>age</span><span>++</span><span>;</span> <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
<span>}</span>
<span>let</span> p <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span><span>;</span>
<span>// (wait a few seconds)</span>
p<span>.</span><span>age</span> <span>// -> not zero</span>
</code></pre></div>
<p>There are a few other differences with arrow functions that are more obscure:</p>
<ul>
<li>Within the arrow function, <code>arguments</code> refers to the surrounding function, not to the argument list of the arrow function.</li>
<li><code>.call()</code>, <code>.bind()</code>, and <code>.apply()</code> cannot change the scope of an arrow function. They still work otherwise (and have the same function signatures themselves). If you use them, <code>this</code> within the arrow function will just be unchanged.</li>
</ul>
<h3>Refactoring recommendation</h3>
<blockquote>
<p>Use arrow functions extensively. They are way better. One important thing to note, however, is that you still must use the anonymous-function syntax for method declarations:</p>
<div><pre><code>let MyClass = BaseClass.extend({
   myMethod: function() {
      return &#x26;#39;the return&#x26;#39;;
   }
});</code></pre></div>
</blockquote>
<h2>Template strings</h2>
<p>Template strings are common in other programming languages (Like PHP, Python, and Ruby). They let you avoid code like this, which is extremely prone to errors and typos:</p>
<div><pre><code><span>let</span> now <span>=</span> month <span>+</span> <span>' '</span> <span>+</span> day <span>+</span> <span>', '</span> <span>+</span> year <span>+</span> <span>' '</span> <span>+</span> hour <span>+</span> <span>':'</span> <span>+</span> minute<span>;</span>
</code></pre></div>
<p>With template strings you can write:</p>
<div><pre><code><span>let</span> now <span>=</span> <span><span>`</span><span><span>${</span>month<span>}</span></span><span> </span><span><span>${</span>day<span>}</span></span><span>, </span><span><span>${</span>year<span>}</span></span><span> </span><span><span>${</span>hour<span>}</span></span><span>:</span><span><span>${</span>minute<span>}</span></span><span>`</span></span><span>;</span>
</code></pre></div>
<p>Template strings start and end with backticks (`). You can put any expression within the templates:</p>
<div><pre><code><span>let</span> a <span>=</span> <span>2</span><span>;</span>
<span>let</span> myString <span>=</span> <span><span>`</span><span>2 plus </span><span><span>${</span>a<span>}</span></span><span> is </span><span><span>${</span><span>2</span> <span>+</span> a<span>}</span></span><span>`</span></span><span>;</span>
<span>// -> "2 plus 2 is 4"</span>
</code></pre></div>
<p>Template strings can also be multi-line:</p>
<div><pre><code><span>let</span> myString <span>=</span> <span><span>`</span><span>This is a</span>
<span>multi-line string</span><span>`</span></span><span>;</span>
<span>// -> "This is a\nmulti-line string"</span>
</code></pre></div>
<h3>Refactoring recommendation</h3>
<blockquote>
<p>Use template strings in most cases where you would normally use string concatenation. Definitely use template strings for multi-line strings. They are particularly useful for inline templates in Angular directives.</p>
</blockquote>
<h2>New String methods</h2>
<p>The <code>String</code> class has a few new useful methods. The most useful ones are:</p>
<ul>
<li><code>haystack.includes(needle)</code> - tests if a <code>haystack</code> includes <code>needle</code>. No more <code>haystack.indexOf(needle)</code>!</li>
<li><code>haystack.startsWith(needle)</code> and <code>haystack.endsWith(needle)</code> - self explanatory.</li>
<li><code>'test '.repeat(3)</code> - returns <code>'test test test '</code>.</li>
</ul>
<h3>Refactoring recommendation</h3>
<blockquote>
<p>Definitely use these methods instead of <code>indexOf()</code> for checking for substrings. They are much more readable.</p>
</blockquote>
</article></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"refactoring-an-existing-nodejs-app-for-es2015-part-1","contentHtml":"\u003cp\u003eThinking of getting started with ES2015? Coding with NodeJS v5.0.0 or higher? You can get started today! Node supports many features of ES2015 natively, without the need for a transpiler like Babel or Traceur.\u003c/p\u003e\n\u003cp\u003eES2015 actually has a \u003cem\u003elot\u003c/em\u003e of really awesome features, and I think most of them are worthwhile to start using eventually. But, it you already have a Node app written and want to introduce ES2015 gradually, which features should you pick first?\u003c/p\u003e\n\u003cp\u003eThis post talks about the three ES2015 features that I would focus on first. I picked these because they are the most compatible with existing patterns and are the easiest for developers to pick up and start using right away. They are also all supported fully in Node 5.x.\u003c/p\u003e\n\u003cp\u003eThe features are:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eBlock-scoped declarations (\u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003econst\u003c/code\u003e)\u003c/li\u003e\n\u003cli\u003eArrow functions\u003c/li\u003e\n\u003cli\u003eTemplate strings and new \u003ccode\u003eString\u003c/code\u003e methods\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003ePart 2 will of this series will talk about classes.\u003c/p\u003e\n\u003ch2\u003eStart using block-scoped variable declarations (\u003ccode\u003elet\u003c/code\u003e and \u003ccode\u003econst\u003c/code\u003e) instead of \u003ccode\u003evar\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003eNote:\u003c/strong\u003e You need to be in strict mode (\u003ccode\u003e'use strict'\u003c/code\u003e) for these keywords to work. If you are using the Node REPL, you need to start it with \u003ccode\u003enode --use_strict\u003c/code\u003e as opposed to typing \u003ccode\u003e'use strict';\u003c/code\u003e within the REPL.\u003c/p\u003e\n\u003ch3\u003eWhat is this \u003ccode\u003elet\u003c/code\u003e business?\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003evar\u003c/code\u003e keyword has a few issues that have been corrected by the new \u003ccode\u003elet\u003c/code\u003e keyword. First of all, \u003ccode\u003evar\u003c/code\u003e may be hoisted like this:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003ebla \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e bla\u003cspan\u003e;\u003c/span\u003e\n\n\u003cspan\u003e// is identical to:\u003c/span\u003e\n\u003cspan\u003evar\u003c/span\u003e bla\u003cspan\u003e;\u003c/span\u003e\nbla \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eSecond of all, \u003ccode\u003evar\u003c/code\u003e-defined variables have the scope of \u003cem\u003eentire\u003c/em\u003e enclosing function.\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003evarExample\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003evar\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  \u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003etrue\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n    \u003cspan\u003evar\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \u003cspan\u003e// same variable!\u003c/span\u003e\n    \u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ex\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \u003cspan\u003e// 2\u003c/span\u003e\n  \u003cspan\u003e}\u003c/span\u003e\n  \u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ex\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e  \u003cspan\u003e// 2\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThe \u003ccode\u003elet\u003c/code\u003e keyword avoids all of this weirdness. When you use \u003ccode\u003elet\u003c/code\u003e there is no hoisting, so you will get a ReferenceError at runtime:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   c \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n   \u003cspan\u003elet\u003c/span\u003e c \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n   \u003cspan\u003ereturn\u003c/span\u003e c\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003ea\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// ReferenceError: c is not defined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eVariables declared with \u003ccode\u003elet\u003c/code\u003e are block-scoped, not function scoped. A block is any section of code delimited with \u003ccode\u003e{ ... }\u003c/code\u003e. Here's an example:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e x \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e y \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eif\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ey \u003cspan\u003e\u003e\u003c/span\u003e x\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n  \u003cspan\u003elet\u003c/span\u003e a \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n  x \u003cspan\u003e=\u003c/span\u003e a\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ex\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// 3\u003c/span\u003e\n\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ey\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// 2\u003c/span\u003e\n\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003ea\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// ReferenceError: a is not defined.\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003eWhat about \u003ccode\u003econst\u003c/code\u003e?\u003c/h3\u003e\n\u003cp\u003eThe \u003ccode\u003econst\u003c/code\u003e keyword follows the same scoping and (non-) hoisting rules as \u003ccode\u003elet\u003c/code\u003e. It has one more constraint, though: variables declared with \u003ccode\u003econst\u003c/code\u003e don't change their reference.\u003c/p\u003e\n\u003cp\u003eHere's a few examples:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eA\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eA\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e   \u003cspan\u003e// TypeError: assignment to a constant variable\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eIt's also important to realize that \u003ccode\u003econst\u003c/code\u003e doesn't enforce immutability for objects. You \u003cem\u003ecan\u003c/em\u003e change object properties of objects declared with \u003ccode\u003econst\u003c/code\u003e:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003e'use strict'\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003econst\u003c/span\u003e \u003cspan\u003eMY_OBJECT\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003eMyProp\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003eMY_OBJECT\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eMyProp\u003c/span\u003e\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// no error here!\u003c/span\u003e\n\u003cspan\u003econsole\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003elog\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003eMY_OBJECT\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003e\u003cspan\u003eMyProp\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003eRefactoring recommendation\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eIf it is possible to use \u003ccode\u003econst\u003c/code\u003e, use it. If it isn't possible to use \u003ccode\u003econst\u003c/code\u003e, use \u003ccode\u003elet\u003c/code\u003e. Don't use \u003ccode\u003evar\u003c/code\u003e anymore, unless you find some crazy edge-case where it is necessary.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eArrow functions\u003c/h2\u003e\n\u003cp\u003eArrow functions are a shorthand for writing small, anonymous functions. They also adopt the scope of their surrounding code, rather than creating a new one. This can eliminate use of the \u003ccode\u003evar self = this;\u003c/code\u003e pattern, and eliminate some uses of \u003ccode\u003e.bind()\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eArrow functions also have a further-shortened version for implicitly returning the value of an expression. This is great for iterators and lodash-style functional programming.\u003c/p\u003e\n\u003cp\u003eHere are some examples:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e myArray \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e[\u003c/span\u003e\u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e3\u003c/span\u003e\u003cspan\u003e]\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e// These are all equivalent:\u003c/span\u003e\nmyArray\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e i \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\nmyArray\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ereturn\u003c/span\u003e i \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\nmyArray\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e i \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\nmyArray\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003e\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003ei \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\nmyArray\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003e\u003c/span\u003e i \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// expression (i + 1) must be on one line\u003c/span\u003e\nmyArray\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003emap\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003ei\u003c/span\u003e \u003cspan\u003e=\u003e\u003c/span\u003e i \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e1\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// also must be on one line\u003c/span\u003e\n\u003cspan\u003e// all return [2, 3, 4]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eHere's an example of the way \u003ccode\u003ethis\u003c/code\u003e works with arrow functions:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003e\u003cspan\u003ePerson\u003c/span\u003e\u003c/span\u003e \u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n   \u003cspan\u003esetInterval\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003efunction\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e1000\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e p \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003ePerson\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\np\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// -\u003e 0\u003c/span\u003e\n\u003cspan\u003e// (wait a few seconds)\u003c/span\u003e\np\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e// -\u003e still 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eYou could fix this with \u003ccode\u003eself\u003c/code\u003e, but that is annoying. Arrow functions make this easier:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003efunction\u003c/span\u003e \u003cspan\u003e\u003cspan\u003ePerson\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e\n   \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e0\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n   \u003cspan\u003esetInterval\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e \u003cspan\u003e=\u003e\u003c/span\u003e \u003cspan\u003e{\u003c/span\u003e \u003cspan\u003ethis\u003c/span\u003e\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e\u003cspan\u003e++\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e \u003cspan\u003e}\u003c/span\u003e\u003cspan\u003e,\u003c/span\u003e \u003cspan\u003e1000\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e}\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e p \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003enew\u003c/span\u003e \u003cspan\u003ePerson\u003c/span\u003e\u003cspan\u003e(\u003c/span\u003e\u003cspan\u003e)\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e// (wait a few seconds)\u003c/span\u003e\np\u003cspan\u003e.\u003c/span\u003e\u003cspan\u003eage\u003c/span\u003e \u003cspan\u003e// -\u003e not zero\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eThere are a few other differences with arrow functions that are more obscure:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eWithin the arrow function, \u003ccode\u003earguments\u003c/code\u003e refers to the surrounding function, not to the argument list of the arrow function.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e.call()\u003c/code\u003e, \u003ccode\u003e.bind()\u003c/code\u003e, and \u003ccode\u003e.apply()\u003c/code\u003e cannot change the scope of an arrow function. They still work otherwise (and have the same function signatures themselves). If you use them, \u003ccode\u003ethis\u003c/code\u003e within the arrow function will just be unchanged.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRefactoring recommendation\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUse arrow functions extensively. They are way better. One important thing to note, however, is that you still must use the anonymous-function syntax for method declarations:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003elet MyClass = BaseClass.extend({\n   myMethod: function() {\n      return \u0026#x26;#39;the return\u0026#x26;#39;;\n   }\n});\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eTemplate strings\u003c/h2\u003e\n\u003cp\u003eTemplate strings are common in other programming languages (Like PHP, Python, and Ruby). They let you avoid code like this, which is extremely prone to errors and typos:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e now \u003cspan\u003e=\u003c/span\u003e month \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e' '\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e day \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e', '\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e year \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e' '\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e hour \u003cspan\u003e+\u003c/span\u003e \u003cspan\u003e':'\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e minute\u003cspan\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eWith template strings you can write:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e now \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e${\u003c/span\u003emonth\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u003cspan\u003e${\u003c/span\u003eday\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e, \u003c/span\u003e\u003cspan\u003e\u003cspan\u003e${\u003c/span\u003eyear\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e \u003c/span\u003e\u003cspan\u003e\u003cspan\u003e${\u003c/span\u003ehour\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e:\u003c/span\u003e\u003cspan\u003e\u003cspan\u003e${\u003c/span\u003eminute\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTemplate strings start and end with backticks (`). You can put any expression within the templates:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e a \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e2\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003elet\u003c/span\u003e myString \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003e2 plus \u003c/span\u003e\u003cspan\u003e\u003cspan\u003e${\u003c/span\u003ea\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e is \u003c/span\u003e\u003cspan\u003e\u003cspan\u003e${\u003c/span\u003e\u003cspan\u003e2\u003c/span\u003e \u003cspan\u003e+\u003c/span\u003e a\u003cspan\u003e}\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e// -\u003e \"2 plus 2 is 4\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eTemplate strings can also be multi-line:\u003c/p\u003e\n\u003cdiv\u003e\u003cpre\u003e\u003ccode\u003e\u003cspan\u003elet\u003c/span\u003e myString \u003cspan\u003e=\u003c/span\u003e \u003cspan\u003e\u003cspan\u003e`\u003c/span\u003e\u003cspan\u003eThis is a\u003c/span\u003e\n\u003cspan\u003emulti-line string\u003c/span\u003e\u003cspan\u003e`\u003c/span\u003e\u003c/span\u003e\u003cspan\u003e;\u003c/span\u003e\n\u003cspan\u003e// -\u003e \"This is a\\nmulti-line string\"\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003ch3\u003eRefactoring recommendation\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUse template strings in most cases where you would normally use string concatenation. Definitely use template strings for multi-line strings. They are particularly useful for inline templates in Angular directives.\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eNew String methods\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eString\u003c/code\u003e class has a few new useful methods. The most useful ones are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ehaystack.includes(needle)\u003c/code\u003e - tests if a \u003ccode\u003ehaystack\u003c/code\u003e includes \u003ccode\u003eneedle\u003c/code\u003e. No more \u003ccode\u003ehaystack.indexOf(needle)\u003c/code\u003e!\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ehaystack.startsWith(needle)\u003c/code\u003e and \u003ccode\u003ehaystack.endsWith(needle)\u003c/code\u003e - self explanatory.\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e'test '.repeat(3)\u003c/code\u003e - returns \u003ccode\u003e'test test test '\u003c/code\u003e.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eRefactoring recommendation\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eDefinitely use these methods instead of \u003ccode\u003eindexOf()\u003c/code\u003e for checking for substrings. They are much more readable.\u003c/p\u003e\n\u003c/blockquote\u003e\n","layout":"post","status":"publish","published":true,"title":"Refactoring an Existing NodeJS App for ES2015 (Part 1)","author":{"display_name":"afiedler","login":"afiedler","email":"andy@andyfiedler.com","url":""},"author_login":"afiedler","author_email":"andy@andyfiedler.com","wordpress_id":356,"wordpress_url":"http://andyfiedler.com/?p=356","date":"2016-01-13 11:12:53 -0500","date_gmt":"2016-01-13 16:12:53 -0500","categories":["Tech Notes"],"tags":["nodejs","es2015"]}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"refactoring-an-existing-nodejs-app-for-es2015-part-1"},"buildId":"Jjjk-tfnOMqoXTjgl9oWU","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>