{"pageProps":{"postData":{"id":"mongodb-stream-to-hapi","contentHtml":"<p>Let's say you are implementing a REST endpoint that lists a collection. Normally, you'd paginate the endpoint with a\nmaximum page size of say 25 items to avoid memory issues. You'd return something like this example, and if the client\nwants more than one page, it would need to make more than one request:</p>\n<div><pre><code><span>{</span>\n  <span>\"data\"</span><span>:</span> <span>[</span>\n    <span>{</span> <span>\"id\"</span><span>:</span> <span>1</span><span>,</span> <span>\"title\"</span><span>:</span> <span>\"Item 1\"</span> <span>}</span><span>,</span>\n    <span>{</span> <span>\"id\"</span><span>:</span> <span>2</span><span>,</span> <span>\"title\"</span><span>:</span> <span>\"Item 2\"</span> <span>}</span>\n  <span>]</span><span>,</span>\n  <span>\"pages\"</span><span>:</span> <span>{</span>\n    <span>\"current\"</span><span>:</span> <span>2</span><span>,</span>\n    <span>\"prev\"</span><span>:</span> <span>1</span><span>,</span>\n    <span>\"hasPrev\"</span><span>:</span> <span>true</span><span>,</span>\n    <span>\"next\"</span><span>:</span> <span>3</span><span>,</span>\n    <span>\"hasNext\"</span><span>:</span> <span>true</span><span>,</span>\n    <span>\"total\"</span><span>:</span> <span>5</span>\n  <span>}</span><span>,</span>\n  <span>\"items\"</span><span>:</span> <span>{</span>\n    <span>\"perPage\"</span><span>:</span> <span>2</span><span>,</span>\n    <span>\"begin\"</span><span>:</span> <span>3</span><span>,</span>\n    <span>\"end\"</span><span>:</span> <span>4</span><span>,</span>\n    <span>\"total\"</span><span>:</span> <span>9</span>\n  <span>}</span>\n<span>}</span>\n</code></pre></div>\n<p>This can be a real pain for clients to deal with, especially if the client knows it wants <em>everything</em>. With NodeJS,\nyou may be able to greatly increase the maximum page size or eliminate it completely with streams. This is because\nwith streams you don't need to buffer the entire response before sending it. You can send the response piece by piece,\ngreatly reducing the memory demands on the server.</p>\n<p>If you are using MongoDB, you can get a streaming response from the database like this:</p>\n<div><pre><code><span>const</span> mongoStream <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>\"items\"</span><span>)</span><span>.</span><span>find</span><span>(</span><span>{</span><span>}</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>;</span>\n</code></pre></div>\n<p>This will be an <code>objectMode</code> stream, with each object one document from your MongoDB collection. HapiJS also supports\nstreaming responses like this:</p>\n<div><pre><code><span>// Within your handler</span>\n<span>return</span> <span>reply</span><span>(</span>responseStream<span>)</span><span>;</span>\n</code></pre></div>\n<p>HapiJS response streams should be in binary mode or in <code>objectMode</code> emitting strings. You can't just connect your\nMongoDB stream to HapiJS because you need to construct a valid JSON object so the client can parse it. To do that, you\ncan pipe your MongoDB stream through a <code>Transform</code> stream that takes in MongoDB documents and emits a JSON object piece\nby piece that will look like the response above. Here's an example of a stream that does that:</p>\n<div><pre><code><span>// PaginationStream.js</span>\n<span>const</span> <span>Transform</span> <span>=</span> <span>require</span><span>(</span><span>\"stream\"</span><span>)</span><span>.</span><span><span>Transform</span></span><span>;</span>\n<span>const</span> assert <span>=</span> <span>require</span><span>(</span><span>\"assert\"</span><span>)</span><span>;</span>\n\n<span>class</span> <span>PaginationStream</span> <span>extends</span> <span>Transform</span> <span>{</span>\n  <span>/**\n   * Create a PaginationStream\n   * <span>@param</span> <span>page</span> <span>{</span>Number<span>}</span> which page of data will be streamed through\n        (starting with 1)\n   * <span>@param</span> <span>perPage</span> <span>{</span>Number<span>}</span> how many objects are returned per page\n        (>= 0; if 0, then return all objects)\n   * <span>@param</span> <span>total</span> <span>{</span>Number<span>}</span> the total number of results (>= 0)\n   */</span>\n  <span>constructor</span><span>(</span><span>page<span>,</span> perPage<span>,</span> total</span><span>)</span> <span>{</span>\n    <span>assert</span><span>(</span>page <span>>=</span> <span>1</span><span>,</span> <span>\"page should be >= 1\"</span><span>)</span><span>;</span>\n    <span>assert</span><span>(</span>perPage <span>>=</span> <span>0</span><span>,</span> <span>\"perPage should be >= 0\"</span><span>)</span><span>;</span>\n    <span>assert</span><span>(</span>total <span>>=</span> <span>0</span><span>,</span> <span>\"total should be >= 0\"</span><span>)</span><span>;</span>\n    <span>super</span><span>(</span><span>{</span> objectMode<span>:</span> <span>true</span> <span>}</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span><span>page</span> <span>=</span> page<span>;</span>\n    <span>this</span><span>.</span><span>perPage</span> <span>=</span> perPage<span>;</span>\n    <span>this</span><span>.</span><span>total</span> <span>=</span> total<span>;</span>\n    <span>this</span><span>.</span><span>count</span> <span>=</span> <span>0</span><span>;</span>\n    <span>this</span><span>.</span><span>perPageReached</span> <span>=</span> <span>false</span><span>;</span>\n  <span>}</span>\n\n  <span>_transform</span><span>(</span><span>data<span>,</span> encoding<span>,</span> callback</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span><span>perPageReached</span><span>)</span> <span>{</span>\n      <span>return</span> <span>callback</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>\"pagination page limit already reached\"</span><span>)</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>if</span> <span>(</span><span>this</span><span>.</span><span>count</span> <span>===</span> <span>0</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span><span>push</span><span>(</span><span>'{\\n  \"data\":['</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>this</span><span>.</span><span>push</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>data<span>,</span> <span>null</span><span>,</span> <span>2</span><span>)</span><span>)</span><span>;</span>\n    <span>this</span><span>.</span><span>count</span><span>++</span><span>;</span>\n\n    <span>// When we reach the limit or the total number of objects, emit an</span>\n    <span>// end of array marker and the pagination object</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span><span>_isEndOfPage</span><span>(</span><span>)</span><span>)</span> <span>{</span>\n      <span>this</span><span>.</span><span>perPageReached</span> <span>=</span> <span>true</span><span>;</span>\n      <span>const</span> pagination <span>=</span> <span>PaginationStream</span><span>.</span><span>_paginationObject</span><span>(</span>\n        <span>this</span><span>.</span><span>page</span><span>,</span>\n        <span>this</span><span>.</span><span>total</span><span>,</span>\n        <span>this</span><span>.</span><span>perPage</span>\n      <span>)</span><span>;</span>\n      <span>const</span> paginationJson <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>pagination<span>,</span> <span>null</span><span>,</span> <span>2</span><span>)</span><span>.</span><span>replace</span><span>(</span>\n        <span><span>/</span><span><span>^</span>{</span><span>/</span></span><span>,</span>\n        <span>\"\"</span>\n      <span>)</span><span>;</span>\n      <span>this</span><span>.</span><span>push</span><span>(</span><span>\"], \"</span><span>)</span><span>;</span>\n      <span>this</span><span>.</span><span>push</span><span>(</span>paginationJson<span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>this</span><span>.</span><span>push</span><span>(</span><span>\",\"</span><span>)</span><span>;</span>\n    <span>}</span>\n\n    <span>return</span> <span>callback</span><span>(</span><span>)</span><span>;</span>\n  <span>}</span>\n\n  <span>_isEndOfPage</span><span>(</span><span>)</span> <span>{</span>\n    <span>if</span> <span>(</span><span>this</span><span>.</span><span>perPage</span> <span>></span> <span>0</span><span>)</span> <span>{</span>\n      <span>// Has a per-page limit if perPage > 0</span>\n      <span>return</span> <span>this</span><span>.</span><span>count</span> <span>===</span> <span>Math</span><span>.</span><span>min</span><span>(</span><span>this</span><span>.</span><span>total</span><span>,</span> <span>this</span><span>.</span><span>perPage</span><span>)</span><span>;</span>\n    <span>}</span> <span>else</span> <span>{</span>\n      <span>// No per-page limit if perPage === 0</span>\n      <span>return</span> <span>this</span><span>.</span><span>count</span> <span>===</span> <span>this</span><span>.</span><span>total</span><span>;</span>\n    <span>}</span>\n  <span>}</span>\n\n  <span>/**\n   * Returns a pagination object\n   * <span>@param</span> <span>page</span> <span>{</span>Number<span>}</span> current page number\n   * <span>@param</span> <span>total</span> <span>{</span>Number<span>}</span> total number of objects\n   * <span>@param</span> <span>perPage</span> <span>{</span>Number<span>}</span> number of objects per page\n   * <span>@private</span>\n   */</span>\n  <span>static</span> <span>_paginationObject</span><span>(</span><span>page<span>,</span> total<span>,</span> perPage</span><span>)</span> <span>{</span>\n    <span>const</span> countNum <span>=</span> perPage <span>===</span> <span>0</span> <span>?</span> total <span>:</span> perPage<span>,</span>\n      begin <span>=</span> <span>(</span>page <span>-</span> <span>1</span><span>)</span> <span>*</span> countNum <span>+</span> <span>1</span><span>,</span>\n      end <span>=</span> page <span>*</span> countNum <span>></span> total <span>?</span> total <span>:</span> page <span>*</span> countNum<span>;</span>\n\n    <span>return</span> <span>{</span>\n      pages<span>:</span> <span>{</span>\n        current<span>:</span> page<span>,</span>\n        prev<span>:</span> page <span>-</span> <span>1</span><span>,</span>\n        hasPrev<span>:</span> page <span>></span> <span>1</span><span>,</span>\n        next<span>:</span> page <span>+</span> <span>1</span><span>,</span>\n        hasNext<span>:</span> total <span>></span> end<span>,</span>\n        total<span>:</span> <span>Math</span><span>.</span><span>ceil</span><span>(</span>total <span>/</span> countNum<span>)</span><span>,</span>\n      <span>}</span><span>,</span>\n      items<span>:</span> <span>{</span>\n        perPage<span>,</span>\n        begin<span>,</span>\n        end<span>,</span>\n        total<span>,</span>\n      <span>}</span><span>,</span>\n    <span>}</span><span>;</span>\n  <span>}</span>\n<span>}</span>\n\nmodule<span>.</span><span>exports</span> <span>=</span> <span>PaginationStream</span><span>;</span>\n</code></pre></div>\n<p>You can use these streams together like this:</p>\n<div><pre><code><span>const</span> total <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>\"items\"</span><span>)</span><span>.</span><span>find</span><span>(</span><span>{</span><span>}</span><span>)</span><span>.</span><span>count</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> mongoStream <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>\"items\"</span><span>)</span><span>.</span><span>find</span><span>(</span><span>{</span><span>}</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>;</span>\n<span>const</span> paginationStream <span>=</span> <span>new</span> <span>PaginationStream</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> total<span>)</span><span>;</span>\n\n<span>return</span> <span>reply</span><span>(</span>mongoStream<span>.</span><span>pipe</span><span>(</span>paginationStream<span>)</span><span>)</span><span>;</span>\n</code></pre></div>\n<p>This is pretty good, but if the response is large, we really need to gzip it. Luckily, Node provides a GZip stream that\nwe can use.</p>\n<div><pre><code>db<span>.</span><span>collection</span><span>(</span><span>\"items\"</span><span>)</span>\n  <span>.</span><span>find</span><span>(</span><span>{</span><span>}</span><span>)</span>\n  <span>.</span><span>count</span><span>(</span><span>(</span><span>err<span>,</span> total</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> mongoStream <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>\"items\"</span><span>)</span><span>.</span><span>find</span><span>(</span><span>{</span><span>}</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>;</span>\n    <span>const</span> paginationStream <span>=</span> <span>new</span> <span>PaginationStream</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> total<span>)</span><span>;</span>\n    <span>const</span> gzipStream <span>=</span> <span>createGzip</span><span>(</span><span>)</span><span>;</span>\n\n    <span>const</span> stream <span>=</span> mongoStream<span>.</span><span>pipe</span><span>(</span>paginationStream<span>)</span><span>.</span><span>pipe</span><span>(</span>gzipStream<span>)</span><span>;</span>\n\n    <span>return</span> <span>reply</span><span>(</span>stream<span>)</span><span>.</span><span>header</span><span>(</span><span>\"content-encoding\"</span><span>,</span> <span>\"gzip\"</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n</code></pre></div>\n<p>There are a few edge cases that we need to deal with, though:</p>\n<ol>\n<li>If your response is taking a really long time, the user could close the tab of the browser which would close the\nsocket. If the socket is closed, we need to stop the stream both to save resources and because the gzip stream will emit\nan error if we try to send data to it after the socket closes.</li>\n<li>There could be some kind of MongoDB error mid-stream (unlikely, but I'll show you how to handle it anyway)</li>\n</ol>\n<p>To handle these edge cases, we'll attach error handlers to the streams and log the errors. Whenever an error handler is\nattached to a stream, Node will assume the application is dealing with the error. If there is no error handler on a\nstream, any error in the stream causes the process to quit like an unhandled exception.</p>\n<p>Here's the code with error handlers added. Maybe there is a more concise way just trapping all errors, but this is what\nis working for me:</p>\n<div><pre><code>db<span>.</span><span>collection</span><span>(</span><span>\"items\"</span><span>)</span>\n  <span>.</span><span>find</span><span>(</span><span>{</span><span>}</span><span>)</span>\n  <span>.</span><span>count</span><span>(</span><span>(</span><span>err<span>,</span> total</span><span>)</span> <span>=></span> <span>{</span>\n    <span>const</span> mongoStream <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>\"items\"</span><span>)</span><span>.</span><span>find</span><span>(</span><span>{</span><span>}</span><span>)</span><span>.</span><span>stream</span><span>(</span><span>)</span><span>;</span>\n    mongoStream<span>.</span><span>on</span><span>(</span><span>\"error\"</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>\n      request<span>.</span><span>log</span><span>(</span><span>[</span><span>\"warn\"</span><span>]</span><span>,</span> <span>{</span> stream<span>:</span> <span>\"mongo\"</span><span>,</span> err <span>}</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>const</span> paginationStream <span>=</span> <span>new</span> <span>PaginationStream</span><span>(</span><span>1</span><span>,</span> <span>0</span><span>,</span> total<span>)</span><span>;</span>\n    paginationStream<span>.</span><span>on</span><span>(</span><span>\"error\"</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>\n      request<span>.</span><span>log</span><span>(</span><span>[</span><span>\"warn\"</span><span>]</span><span>,</span> <span>{</span> stream<span>:</span> <span>\"pagination\"</span><span>,</span> err <span>}</span><span>)</span><span>;</span>\n      mongoStream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>const</span> gzipStream <span>=</span> <span>createGzip</span><span>(</span><span>)</span><span>;</span>\n    paginationStream<span>.</span><span>on</span><span>(</span><span>\"error\"</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>\n      request<span>.</span><span>log</span><span>(</span><span>[</span><span>\"warn\"</span><span>]</span><span>,</span> <span>{</span> stream<span>:</span> <span>\"gzip\"</span><span>,</span> err <span>}</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>// Handle the browser cancelling the request</span>\n    request<span>.</span><span>raw</span><span>.</span><span>req</span><span>.</span><span>once</span><span>(</span><span>\"close\"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>\n      request<span>.</span><span>log</span><span>(</span><span>[</span><span>\"debug\"</span><span>]</span><span>,</span> <span>{</span>\n        msg<span>:</span> <span>\"stream closed due to client cancellation\"</span><span>,</span>\n      <span>}</span><span>)</span><span>;</span>\n      <span>return</span> mongoStream<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>\n    <span>}</span><span>)</span><span>;</span>\n\n    <span>const</span> stream <span>=</span> mongoStream<span>.</span><span>pipe</span><span>(</span>paginationStream<span>)</span><span>.</span><span>pipe</span><span>(</span>gzipStream<span>)</span><span>;</span>\n\n    <span>return</span> <span>reply</span><span>(</span>stream<span>)</span><span>.</span><span>header</span><span>(</span><span>\"content-encoding\"</span><span>,</span> <span>\"gzip\"</span><span>)</span><span>;</span>\n  <span>}</span><span>)</span><span>;</span>\n</code></pre></div>\n<p>There you go! MongoDB streaming HTTP requests using Hapi. A few other things to keep in mind:</p>\n<ul>\n<li>You need to change the Mongo <code>.find()</code> and <code>.count()</code> calls to also implement your pagination logic. You should use\n<code>.sort()</code>, <code>.seek()</code> and <code>.limit()</code> to only return one page of data from the database. If you return more than a page of\ndata, PaginatedStream will emit an error event.</li>\n<li>When using streaming responses, the headers are sent as soon as the first bit of data comes down the stream. There is\nno way to change the headers after data has been sent, so you <em>cannot</em> change the HTTP status code of the response if\nthere is an error mid-stream. I might do another post on some strategies to deal with that issue later.</li>\n</ul>\n","title":"Streaming Hapi Responses with MongoDB","date":"2017-01-10"}},"__N_SSG":true}