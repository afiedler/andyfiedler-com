{"pageProps":{"postData":{"id":"writing-zero-downtime-migrations-for-rails-and-postgres","contentHtml":"<p>Let's suppose you are building an app. It is under heavy development and the dev team is cranking out new features left and right. Developers need to continually change the database schema, but you don't want to take down the app for database migrations if at all possible. How the heck do you do this with Rails?</p>\n<p>We had this problem recently, and have come up with a procedure that solves it for most small database migrations. The goals of this procedure are to:</p>\n<p>Finally, once the production database has been migrated, you should merge your pull request from step 6. This eliminates the dead code supporting the unmigrated version of the database. You should write the code for step 6 at the same time you write the rest of this code. Then just leave the pull request open until you are ready to merge. The advantage of this is that you will be \"cleaning up\" the extraneous code while it is still fresh in your mind.</p>\n<p>Suppose you are dropping a column called \"deleted\". Prior to dropping the column, you have a default scope that excludes deleted rows. After dropping the column, you want the default scope to include all rows.</p>\n<p>You would code a migration to do that like this:</p>\n<div><pre><code><span>class</span> <span>DropDeletedFromPosts</span> <span>&#x3C;</span> <span>ActiveRecord</span><span>:</span><span>:</span><span>Migration</span>\n   <span>def</span> <span><span>up</span></span>\n     drop_column <span>:posts</span><span>,</span> <span>:deleted</span>\n   <span>end</span>\n\n   <span>def</span> <span><span>down</span></span>\n      add_column <span>:posts</span><span>,</span> <span>:boolean</span><span>,</span> <span>:deleted</span><span>,</span> default<span>:</span> <span>false</span><span>,</span> null<span>:</span> <span>false</span>\n   <span>end</span>\n<span>end</span>\n</code></pre></div>\n<p>Then, in your Post model, you'd add branching like this:</p>\n<div><pre><code><span>class</span> <span>Post</span> <span>&#x3C;</span> <span>ActiveRecord</span><span>:</span><span>:</span><span>Base</span>\n\n   <span># TODO: Remove this code after the DropDeletedFromPosts migration has</span>\n   <span># been applied.</span>\n   <span>if</span> <span>Post</span><span>.</span>attribute_names<span>.</span><span>include</span><span>?</span> <span>'deleted'</span>\n      default_scope <span>-</span><span>></span> <span>{</span> where<span>(</span>deleted<span>:</span> <span>false</span><span>)</span> <span>}</span>\n   <span>end</span>\n\n   <span># Other model code here ...</span>\n\n<span>end</span>\n</code></pre></div>\n<p>Writing zero-downtime migrations is not easy, and you'll need to do a cost-benefit analysis between scheduling downtime and writing lots of hairy branching code to support a zero-downtime deploy. That decision will depend on how downtime impacts your customers and your development schedule.</p>\n<p>Hopefully, if you decide to go the zero-downtime route, this procedure will make your life easier!</p>\n","layout":"post","status":"publish","published":true,"title":"Writing Zero-Downtime Migrations for Rails and Postgres","author":{"display_name":"afiedler","login":"afiedler","email":"andy@andyfiedler.com","url":""},"author_login":"afiedler","author_email":"andy@andyfiedler.com","wordpress_id":265,"wordpress_url":"http://andyfiedler.com/?p=265","date":"2014-04-18 09:38:26 -0400","date_gmt":"2014-04-18 13:38:26 -0400","categories":["Tech Notes"],"tags":["postgres","rails"],"redirect_from":["/blog/writing-zero-downtime-migrations-for-rails-and-postgres-265/","/blog/writing-zero-downtime-migrations-for-rails-and-postgres-265"]}},"__N_SSG":true}